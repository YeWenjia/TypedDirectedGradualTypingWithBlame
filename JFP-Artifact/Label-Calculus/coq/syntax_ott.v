(* generated by Ott 0.30, locally-nameless lngen from: ../ott/rules.ott *)
Require Import Bool.
Require Import Metalib.Metatheory.
Require Import List.
Require Import syntaxb_ott.
(** syntax *)

Parameter ignore : atom.

Parameter label : atom.

Inductive exp : Set :=  (*r expressions *)
 | e_var_b (_:nat) (*r variables *)
 | e_var_f (x:var) (*r variables *)
 | e_lit (i5:i) (*r lit *)
 | e_abs (e:exp)  (*r abstractions *)
 | e_app (e1:exp) (p:var) (b:bool) (e2:exp) (*r applications *)
 | e_anno (e:exp) (p:var) (b:bool) (A:typ) (*r annotation *).

Inductive dirflag : Set :=  (*r checking direction *)
 | Inf : dirflag
 | Chk : dirflag.

 Inductive dirflag2 : Set :=  (*r checking direction *)
 | Inf2 : dirflag2
 | Chk2 (p:var) (b:bool) : dirflag2.

Definition ctx : Set := list ( atom * typ ).

Definition ls : Set := list st.

(* EXPERIMENTAL *)
(** auxiliary functions on the new list types *)
(** library functions *)
(** subrules *)
(** arities *)
(** opening up abstractions *)
Fixpoint open_exp_wrt_exp_rec (k:nat) (e_5:exp) (e__6:exp) {struct e__6}: exp :=
  match e__6 with
  | (e_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => e_var_b nat
        | inleft (right _) => e_5
        | inright _ => e_var_b (nat - 1)
      end
  | (e_var_f x) => e_var_f x
  | (e_lit i5) => e_lit i5
  | (e_abs e ) => e_abs (open_exp_wrt_exp_rec (S k) e_5 e)
  | (e_app e1 p b e2) => e_app (open_exp_wrt_exp_rec k e_5 e1) p b (open_exp_wrt_exp_rec k e_5 e2)
  | (e_anno e p b A) => e_anno (open_exp_wrt_exp_rec k e_5 e) p b A
end.

Definition open_exp_wrt_exp e_5 e__6 := open_exp_wrt_exp_rec 0 e__6 e_5.

(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_exp *)
Inductive lc_exp : exp -> Prop :=    (* defn lc_exp *)
 | lc_e_var_f : forall (x:var),
     (lc_exp (e_var_f x))
 | lc_e_lit : forall (i5:i),
     (lc_exp (e_lit i5))
 | lc_e_abs : forall (e:exp) ,
      ( forall x , lc_exp  ( open_exp_wrt_exp e (e_var_f x) )  )  ->
     (lc_exp (e_abs e ))
 | lc_e_app : forall (e1 e2:exp) p b ,
     (lc_exp e1) ->
     (lc_exp e2) ->
     (lc_exp (e_app e1 p b e2))
 | lc_e_anno : forall (e:exp)  (p:var) (A:typ) b,
     (lc_exp e) ->
     (lc_exp (e_anno e p b A)).
(** free variables *)
Fixpoint fv_exp (e_5:exp) : vars :=
  match e_5 with
  | (e_var_b nat) => {}
  | (e_var_f x) => {{x}}
  | (e_lit i5) => {}
  | (e_abs e) => (fv_exp e)
  | (e_app e1 p b e2) => (fv_exp e1) \u (fv_exp e2)
  | (e_anno e p b A) => (fv_exp e)
end.

(** substitutions *)
Fixpoint subst_exp (e_5:exp) (x5:var) (e__6:exp) {struct e__6} : exp :=
  match e__6 with
  | (e_var_b nat) => e_var_b nat
  | (e_var_f x) => (if eq_var x x5 then e_5 else (e_var_f x))
  | (e_lit i5) => e_lit i5
  | (e_abs e) => e_abs (subst_exp e_5 x5 e)
  | (e_app e1 p b e2) => e_app (subst_exp e_5 x5 e1) p b (subst_exp e_5 x5 e2)
  | (e_anno e p b A) => e_anno (subst_exp e_5 x5 e) p b A
end.


(* principal types for values*)
Fixpoint principal_type (v:exp) : typ :=
  match v with
  | (e_lit i5) => t_int
  | (e_anno e p b A) => A
  | (e_abs e) => (t_arrow t_dyn t_dyn)
  | _ => t_dyn
  end.


(* defns Values *)
Inductive value : exp -> Prop :=    (* defn value *)
 | value_lit : forall (i5:i),
     value (e_lit i5)
 | value_abs : forall e ,
     lc_exp (e_abs e) ->
     value (e_abs e)
 | value_fanno : forall (v:exp) (A B C D:typ) (p:var) b,
     value v ->
      (t_arrow C D)  =   (principal_type   ( v )  )   ->
     value (e_anno v p b (t_arrow A B))
 | value_dyn : forall (v:exp) (p:var) b,
     Ground   (principal_type  v )   ->
     value v ->
     value  ( (e_anno v p b t_dyn) ).


Inductive walue : exp -> Prop :=    
 | walue_val : forall v,
     value v ->
     walue v
 | walue_abs : forall e ,
     lc_exp (e_abs e) ->
     walue (e_abs e).



Definition FLike A := not (A = t_dyn) /\ not (A = (t_arrow t_dyn t_dyn)) /\ (sim A (t_arrow t_dyn t_dyn)).

Inductive nlam : exp -> Prop :=   
 | nl_var_f : forall (x:var),
     nlam (e_var_f x)
 | nl_lit : forall (i5:i),
     nlam (e_lit i5)
 | nl_app : forall (e1 e2:exp) l b ,
     nlam (e_app e1 l b e2)
 | nl_anno : forall (e:exp) (A:typ) l b ,
     nlam (e_anno e l b A).

(* defns Typing *)
Inductive Typing : ctx -> exp -> dirflag -> typ -> Prop :=    (* defn Typing *)
 | Typ_lit : forall (G:ctx) (i5:i),
      uniq  G  ->
     Typing G (e_lit i5) Inf t_int
 | Typ_var : forall (G:ctx) (x:var) (A:typ),
      uniq  G  ->
      binds  x A G  ->
     Typing G (e_var_f x) Inf A
 | Typ_abs : forall (L:vars) (G:ctx) (A:typ) (e:exp) (B:typ),
      ( forall x , x \notin  L  -> Typing  (cons ( x , A )  G )   ( open_exp_wrt_exp e (e_var_f x) )  Chk B )  ->
     Typing G (e_abs e) Chk (t_arrow A B)
 | Typ_sugar : forall (L:vars) (G:ctx) (e:exp),
     ( forall x , x \notin  L  -> Typing  (cons ( x , t_dyn )  G )   ( open_exp_wrt_exp e (e_var_f x) )  Chk t_dyn )  ->
    Typing G (e_abs e) Inf (t_arrow t_dyn t_dyn)
 | Typ_app : forall (G:ctx) (e1 e2:exp) (B A:typ) p b ,
     Typing G e1 Inf (t_arrow A B) ->
     Typing G e2 Chk A ->
     Typing G (e_app e1 p b e2) Inf B
 | Typ_anno : forall (G:ctx) (e:exp) (p:var) b (A:typ),
     Typing G e Chk A ->
     Typing G  ( (e_anno e p b A) )  Inf A
 | Typ_sim : forall (G:ctx) (e:exp) (B A:typ),
     Typing G e Inf A ->
     sim A B ->
     nlam e ->
     Typing G e Chk B.

Fixpoint cal_p (e:exp) (x:var) : var :=
      match e with
      | (e_anno e p b A) => p
      | _ => x
      end.

Fixpoint cal_b (e:exp) : bool :=
      match e with
      | (e_anno e p b A) => b
      | _ => false
      end.


Inductive ttyping : ctx -> exp -> dirflag2 -> typ -> term -> Prop :=    (* defn Typing *)
 | ttyp_lit : forall (G:ctx) (i5:i) ,
      uniq  G  ->
     ttyping G (e_lit i5) Inf2 t_int (trm_lit i5)
 | ttyp_var : forall (G:ctx) (x:var) (A:typ),
      uniq  G  ->
      binds  x A G  ->
     ttyping G (e_var_f x) Inf2 A (trm_var_f x)
 | ttyp_abs : forall (L:vars) (G:ctx) (A:typ) (e:exp) (B:typ) l b t,
      ( forall x , x \notin  L  -> ttyping  (cons ( x , A )  G )   ( open_exp_wrt_exp e (e_var_f x) )  (Chk2 l b) B ( open_term_wrt_term t (trm_var_f x) ))  ->
     ttyping G (e_abs e) (Chk2 l b) (t_arrow A B) (trm_abs A t)
 | ttyp_sugar : forall (L:vars) (G:ctx) (e:exp) (t:term) ,
     ( forall x , x \notin  L  -> ttyping  (cons ( x , t_dyn )  G )   ( open_exp_wrt_exp e (e_var_f x) )  (Chk2 label true) t_dyn ( open_term_wrt_term t (trm_var_f x) ))  ->
    ttyping G (e_abs e) Inf2 (t_arrow t_dyn t_dyn) (trm_abs t_dyn t)
 | ttyp_app : forall (G:ctx) (e1 e2:exp) (B A:typ) (t1 t2:term) (l:var) b,
     ttyping G e1 Inf2 (t_arrow A B) t1 -> 
     ttyping G e2 (Chk2 l (negb b)) A t2 ->
     ttyping G (e_app e1 l b e2) Inf2 B (trm_app t1 t2)
 | ttyp_anno : forall (G:ctx) (e:exp) (A:typ) l (t:term) b,
     ttyping G e (Chk2 l b) A t ->
     ttyping G  ( (e_anno e l b A) ) Inf2 A t
 | ttyp_sim : forall (G:ctx) (e:exp) (B A:typ) (t:term) (l:var) b,
     ttyping G e Inf2 A t ->
     sim A B ->
     nlam e ->
     ttyping G e (Chk2 l b) B (trm_cast t l b A B).



Inductive ctx_item : Type :=
     | appCtxL : exp -> var -> bool -> ctx_item
     | appCtxR : exp -> var -> bool -> ctx_item
     | annoCtx : var -> bool -> typ -> ctx_item.
   
Notation Evactx := (list ctx_item).
   
Inductive wellformed : ctx_item -> Prop :=
     | wf_appCtxL : forall (e : exp) p b,
                   lc_exp e ->
                    wellformed (appCtxL e p b )
     | wf_appCtxR : forall (v : exp) p b ,
                    value v ->
                    wellformed (appCtxR v p b )
     | wf_annoCtx : forall (A : typ)  (p:var) b,
                    wellformed (annoCtx p b A).
   
Definition fill (E : ctx_item) (e : exp) : exp :=
     match E with
     | appCtxL e2 p b  => e_app e p b e2
     | appCtxR v1 p b => e_app v1 p b e
     | annoCtx p b A => e_anno e p b A
     end.
    
Inductive res : Type :=
     | e_exp  : exp -> res
     | e_blame : var -> bool -> res.    


(* defns Semantics *)
Inductive TypedReduce : exp -> var -> bool -> typ -> res -> Prop :=    (* defn TypedReduce *)
 | TReduce_abs: forall v A B C D p b,
   sim (t_arrow C D) (t_arrow A B) ->
   principal_type v = (t_arrow C D) ->
   TypedReduce v p b (t_arrow A B) (e_exp (e_anno v p b (t_arrow A B)))
  | TReduce_v : forall (v:exp)  (p:var) b,
   Ground(principal_type v) ->
   TypedReduce v p b t_dyn (e_exp (e_anno v p b t_dyn))
 | TReduce_lit : forall (i5:i) b (p:var),
     TypedReduce (e_lit i5) p b t_int (e_exp (e_lit i5))
 | TReduce_dd : forall (v:exp) (p:var) (q:var) b1 b2,
     lc_exp v ->
     TypedReduce  ( (e_anno v q b1 t_dyn) ) p b2 t_dyn  (e_exp  (e_anno v q b1 t_dyn) ) 
 | TReduce_anyd : forall (v:exp) (p:var) b,
      FLike (principal_type  v )  ->
     TypedReduce v p b t_dyn  (e_exp (e_anno  ( (e_anno v p b (t_arrow t_dyn t_dyn)) ) p b t_dyn) ) 
 | TReduce_dyna : forall (v:exp) (A:typ) (p:var) b1 b2 (q:var),
      FLike A ->
     sim (principal_type v) A ->
    TypedReduce  ( (e_anno v q b1 t_dyn) ) p b2 A  (e_exp (e_anno v p b2 A) ) 
 | TReduce_vany : forall (v:exp) (p:var)  (q:var) b1 b2,
   TypedReduce (e_anno v q b1 t_dyn) p b2 (principal_type  v) (e_exp v)
 | TReduce_blame : forall (v:exp) (A:typ) (p:var) b1 b2 (q:var),
      not (sim A (principal_type  v ))  ->
     TypedReduce (e_anno v q b1 t_dyn) p b2 A (e_blame p b2).

  
Inductive step : exp -> res -> Prop :=    (* defn step *)
  | do_step E e1 e2 : 
       wellformed E ->
       step e1 (e_exp e2 ) ->
      step (fill E e1) (e_exp (fill E e2))
  | blame_step E e1 l b:
      wellformed E ->
      step e1 (e_blame l b) ->
      step (fill E e1) (e_blame l b)
  | Step_nbeta : forall (e:exp) (v v' : exp) p b,
    lc_exp (e_abs e) ->
    value v ->
    TypedReduce v p (negb b) t_dyn (e_exp v') ->
    step (e_app (e_abs e) p b v)  (e_exp (e_anno (open_exp_wrt_exp  e v' ) label true t_dyn) ) 
 | Step_beta : forall (A:typ) (e:exp) (B:typ) (v v' : exp) l2 b2 l1 b1,
    lc_exp (e_abs e) ->
    value v ->
    TypedReduce v l2 (negb b2) A (e_exp v') ->
    step (e_app (e_anno (e_abs e) l1 b1 (t_arrow A B)) l2 b2 v)  (e_exp (e_anno  (  (open_exp_wrt_exp  e v' )  )  l1 b1 B) )
 | Step_betap : forall (A:typ) (e:exp) (B:typ) v1 v2 (l2:var) b2 l1 b1,
    value  ( (e_anno v1 l1 b1 (t_arrow A B)) )  ->
    value v2 ->
     TypedReduce v2 l2 (negb b2) A (e_blame l2 (negb b2)) ->
    step (e_app (e_anno v1 l1 b1 (t_arrow A B)) l2 b2 v2)  (e_blame l2 (negb b2))
 | Step_annov : forall (v:exp) (A:typ) (v':res) (l:var) b,
     value v ->
     TypedReduce v l b A v' ->
     not (value (e_anno v l b A)) -> 
     step (e_anno v l b A) v'
 | Step_abeta : forall (v1:exp) (A B:typ) C D (v2 v2':exp) l0 b0 l1 b1 l2 b2 ,
     value  ( (e_anno v1 l0 b0 (t_arrow C D)) )  ->
     value v1 ->
     TypedReduce v2 l2 (negb b2) A (e_exp v2') ->
     value v2 ->
     step (e_app (e_anno (e_anno v1 l0 b0 (t_arrow C D)) l1 b1 (t_arrow A B)) l2 b2 v2) (e_exp (e_anno  ( (e_app (e_anno v1 l0 b0 (t_arrow C D)) l1 b1 v2') ) l1 b1 B)).

Inductive steps : exp -> res -> Prop :=
  | step_refl e:
    steps e (e_exp e)

  | step_n e t' e':   
    step e (e_exp e') ->
    steps e' (e_exp t') ->
    steps e  (e_exp t')

  | step_nb e e' l b:
    step e (e_exp e') ->
    steps e' (e_blame l b) ->
    steps e  (e_blame l b)

  | step_b e l b:
    step e (e_blame l b) ->
    steps e (e_blame l b).

(** infrastructure *)
Hint Constructors nlam Ground walue value sim TypedReduce step steps wellformed Typing ttyping lc_exp : core.

